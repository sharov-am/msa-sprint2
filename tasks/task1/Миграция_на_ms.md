### <a name="_b7urdng99y53"></a>**Название задачи: миграция на микросервисную архитектуру** 
### <a name="_3bfxc9a45514"></a>**Функциональные требования**
C точки зрения функциоанльных требований, новая микросервисная архитектура полностью должна соответствовать текущей монолотной реализации. Т.е. полностью удовлетворять всем функциональным требованиям, существующим на данный момент.


### <a name="_u8xz25hbrgql"></a>**Нефункциональные требования**


|**№**|**Требование**|
| :-: | :- |
|Простота сопровождения|В новой реализации должно быть просто реализовывать новый фичи или сервисы. |
|Масштабируемость| При необходимости, сервисы должны быть масштабированы. |
|Гибкость разработки| Разные команды могут независимо работать над разными сервисами. |
|Кросплатформенность| Сервисы должны работать, по возможности, на любых платформах. |
|Простота тестирования| Сервисы должно быть легко протестировать как вместе, так и по-отдельности. |

### <a name="_qmphm5d6rvi3"></a>**Решение**
Поэтапный переход с монолита на микросервисы будет осуществляться при помощи паттерна Strangler Fig.
Для выбора сервисов, которые будут выделятся из монолита в микросервисы предлагается следующие критерии:

- максимально популярен у пользователей (имеется в виду, частно с ним взаимодействуют);

- меньше всего зависит от других компонентов.

Таким образом, действовать предполагается в пять этапов (по числу необходимых микросервисов). После первого этапа в систему добавляется reverse-proxy для маршуртизации запросов на новый сервис. Далее будут добавлять новые правила маршрутизации для каждого вновь появившегося сервиса. После каждого этапа, для каждого нового микросервиса пишутся тесты, настраивается CI\CD,  каждый микросервис инструментируется для логирования и мониторинга критически важных метрик и параметров. Для каждого микросервиса заводится своя база данных. Это может быть любая подходящая бд. По умолчаню будем использовать Postgres, дабы переиспользовать существующий код. Вообще же, на первое время можно бд оставить как при монолите или разбить бд по соотв. схемам для каждого сервиса. Но все же ориентироваться стоит на отдельные бд для каждого микросервиса.

На первом этапе предполагается выделить UserService. Данный сервис используют все пользователи, он крайне важен, но при этом у него мало зависимостей.  На втором и третьем этапе можно
брать сервисы HotelService и ReviewService. На четвертом этапе предлагается выделить в отдельный микросервис PromocodeService. Ну и в самую последнюю очередь браться за BookingService. В принципе, к данному моменту в монолите он должен остаться один, поэтому с помощью небольшого рефакторинга его можно
превратить в микросервис. После каждого этапа необходимо обновлять правила маршрутизации для reverse-proxy, чтобы соотв. запросы шли на новые микросервисы.

На соотв. C4 диаграммах отображены состояние приложения после 1, 3  этапа.

### <a name="_bjrr7veeh80c"></a>**Альтернативы**
Альтернативное решение предполагает начать с наиболее сложно и важного сервиса, а именно BookingService.
Но, кажется, при данном подходе уйдет слишком много времени на работу над данным сервисом. Кажется, что это будет эквивалентно написанию новогого сервиса с нуля, а не инкрементальных изменений\рефакторинга.


**Недостатки, ограничения, риски**

У выбранного решения я вижу риск в том, что вынос в отдельный микросервис самого важного сервиса с точки бизнеса мы оставляем в самом конце. Соответсвенно, возможны какие-то сюрпризы и нюансы, которые мы не учли и  о которых было бы желательно знать в самом начале. Например, неправильно выделили ограниченные контексты, поэтому переход будет крайне затруднен, если вообще возможен. С другой стороны, при данном функциональном разделении монолита (это по сути модульный монолит) и при грамотном применении паттерна Strangler Fig особых проблем и сюрпризов быть не должно.

